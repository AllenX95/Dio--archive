# apple M1 cache设计的一个秘密

> **类型**: 文章
> **作者**: Dio-晶
> **赞同**: 411
> **评论**: 32
> **时间**: 1608739595
> **原文**: [https://zhuanlan.zhihu.com/p/339116845](https://zhuanlan.zhihu.com/p/339116845)

---

apple M1出来了一段时间了，凡是做CPU的同学都蛮紧张的，毕竟性能摆在那儿，SPECINT2006 单核63分，这是desktop CPU疯狂超频才能达成的分数。

对APPLE的测试业界也做了不少了，我也做了，发现一个巨大而不解的谜题，我也是猜答案，没有真实解。

![](../images/a2f45288b45fe9d8c1acc37969ba9266.jpg)![](../images/a2f45288b45fe9d8c1acc37969ba9266.jpg)

上图是anandtech上对M1的latency测试，公开数据。很奇怪，众所周知M1的L2 cache是12MB容量，如果看这里full random测试曲线，在大约6-8MB容量时延迟开始大幅上扬了。

我可以假设L2的延迟是10ns，SLC的延迟是40ns，我来做的话可能大致也是这个样子。

但为什么单核无法用满12MB的L2 cache容量呢？直白点讲，上图表达的是如果访问的数据段大小超过8MB，会有相当多数据不是从10ns的L2中获取。

我安排人重复了一下anandtech的测试，为了避免是用例有啥特别，就用标准的lmbench测试了，如下，能够重现。

真的就是这么奇怪，当然这个曲线还有一下其他的意义，即曲线的斜率很缓，说明再超越L2容量甚至超越L2+SLC容量之后，DRRIP替换算法在起作用，依旧很多数据能够被驻留cache中被命中。

![](../images/d59406221f9b538f1f88c3299638f2cc.jpg)![](../images/d59406221f9b538f1f88c3299638f2cc.jpg)

然后我又补充了一些测试，那就更有趣了。

![](../images/5dd5721d05a60ead058b4cda67cb707d.jpg)![](../images/5dd5721d05a60ead058b4cda67cb707d.jpg)

绿色和红色的DDR阶段延迟应该是错误配置，无法重现请无视。其他的曲线是基本重合的。

重合曲线代表的意思是，如果在latency core之外再加几个core做memory copy的背景流量，无论加1或2或3core，或者调整各个core的程序包括让latency测试放到从核，测试现象都一致。

**结论（都是猜）：**

**1、单核能够优先使用12MB L2中的一部分，大约是6MB，然后开始溢出到SLC和剩余L2。**

**2、另1/2的6MB L2的访问延迟大于优先使用的6MB L2。也就是说L2分成了near和far两部分，或者说两个BANK ?**

**2、SLC的容量可能是32MB，这其实让我很难理解，dieshot上的尺寸按我的经验没有这么大。**

**3、如果没有人争抢，单核最终是能够获得全部L2+SLC容量的，可能大约是12+32=48MB（甚至可能把小核的4MB也用上? ）在大约20MB尺度访问区间，数据会在L2与SLC之间替换，最终都在SLC命中。**

**3、memory copy类的流量能够被识别，这些流量很奇怪，不会进入优先使用的near 6MB，也不会进入SLC的32MB，只会占掉L2的far的6MB（我感觉占用的情况很复杂，但是推不出明确逻辑）。**

**嗨，继续深入测试吧。要不APPLE的同学跳出来解释一下? 就是很好奇玩了些什么杂技，花里胡哨的。**

![](../images/81463fb9601364af51e30c6054034c3d.jpg)![](../images/81463fb9601364af51e30c6054034c3d.jpg)

---

*由知乎爬虫生成于 2026-02-01 15:39:01*
